% !TeX root = OptCuts.tex

\section{The OptCuts Algorithm}%: Convergence and Implementation Details}
%\section{Implementation Details}
\label{sec:imp}

\begin{algorithm}[h!]
\label{alg:OptCuts}
\caption{OptCuts}

\textbf{Given:} $M$, $T^0$, $U^0$, $b_d$ 

\textbf{Initialize:} $\lambda^0 \leftarrow 0$, \texttt{converged} $\leftarrow$ \textbf{false}, $k \leftarrow 1$\\

\textbf{while} \hspace{2pt} \textbf{!}  \texttt{converged} \hspace{2pt} \textbf{do} \\

%%%----%%%

\hspace{10pt} $\lambda^{k} \leftarrow \max\big(0,\big( E_{d}(T^{k-1}, U^{k-1}) -b_d \big) + \lambda^{k-1}\big)$ \hspace{7pt} // Dual Update (\S\ref{sec:dualUpdate})\\
\hspace{10pt} \texttt{d\_stationary} $\leftarrow$ $| \lambda^{k} - \lambda^{k-1} | < 10^{-3}$ \\

%%%----%%%
\hspace{10pt} // Primal update (\S\ref{sec:primalUpdate}, details in \S\ref{sec:topologySearch}): \\
\hspace{10pt} $i \leftarrow 0$, $(T^{i},U^{i}) \leftarrow (T^{k},U^{k})$, \hspace{2pt} $\delta^{i} \leftarrow 0$ \\
\hspace{10pt} \texttt{v\_converged} $\leftarrow$ \textbf{false}, \texttt{t\_stationary} $\leftarrow$ \textbf{false}, \texttt{t\_stopped} $\leftarrow$ \textbf{false} \\
\hspace{10pt} $o^{0,1} \leftarrow \argmin_{o \in \mathcal{O}^k} d(o)$ \hspace{10pt}//  Get seed topological operation (\S\ref{sec:descent_op})\\

\hspace{10pt} \textbf{if} $d(o^{0,1}) \geq 0$ \\
\hspace{20pt} \texttt{t\_stationary} $\leftarrow$ \textbf{true}\\
\hspace{10pt} \textbf{end if} \\

\hspace{10pt} \textbf{while}  \textbf{!}  ( \texttt{v\_converged} \hspace{2pt} \textbf{and} \hspace{2pt}  \texttt{t\_stopped} ) \hspace{2pt}   \textbf{do} 

%%%----\hspace{20pt} // Topology descent step: \\
\hspace{20pt} \texttt{t\_stopped} $\leftarrow$ \textbf{true} \\
\hspace{20pt} \textbf{if}  \textbf{!} \texttt{t\_stationary} \\
\hspace{30pt} $o^{i,i+1} \leftarrow \argmin_{o \in \mathcal{E}(o^{i-1, i}, T^i)} d(o)$ \hspace{3pt}// Get candidate op (\S\ref{sec:topology_search})  \\
\hspace{30pt} \textbf{if} $d(o^{i,i+1}) < \delta^{i}$ \hspace{10pt} // Sufficient decrease \\
\hspace{40pt} $T^{i+1} \leftarrow o^{i, i+1}(T^i)$ \hspace{10pt} // Update topology (\S\ref{sec:topology_search}) \\
\hspace{40pt} $U^{i+1}_\text{init} \leftarrow (U^{i,i+1}, U_s) $ \hspace{10pt} // Initialize new geometry (\S\ref{sec:topology_search}) \\
\hspace{40pt} \texttt{t\_stopped} $\leftarrow$ \textbf{false} \\
\hspace{30pt} \textbf{else} \\
\hspace{40pt} $T^{i+1} \leftarrow T^i$, \hspace{10pt} $U^{i+1}_\text{init} \leftarrow U^i $ \\
\hspace{30pt} \textbf{end if} \\
\hspace{20pt} \textbf{end if} \\
%%%----\hspace{20pt} // Vertex descent step: \\

\hspace{20pt}  $i \leftarrow i+1$ \\
\hspace{20pt}  $g \leftarrow \nabla_{\small{U}} E_{d}(T^i,U^i_\text{init})$ \hspace{10pt}//  Distortion energy gradient 

\hspace{20pt}\textbf{if} $\|g\| > 10^{-6}$ \hspace{2pt} \\

\hspace{30pt} $H \leftarrow \text{Project}(\nabla_{\small{U}}^2 E_d(T^i,U^{i}_\text{init}))$ \hspace{10pt}// Projected-Hessian (\S\ref{sec:descentStep}) \\

\hspace{30pt} Solve: $H p = -g$ \hspace{10pt} // Get smooth descent direction $p$ (\S\ref{sec:descentStep}) \\

\hspace{30pt} $\alpha \leftarrow \text{LineSearch}(U^{i}_\text{init}, p, E_d)$ \hspace{10pt} // Line-search (\S\ref{sec:descentStep}) \\

\hspace{30pt} $U^{i} \leftarrow U^i_\text{init} + \alpha p$  \\
		
\hspace{30pt} $\delta^{i} \leftarrow E_{d}(T^i,U^{i}) - E_{d}(T^i,U^i_\text{init})$  \\

\hspace{30pt}\textbf{if} $|\delta^{i}/E_{d}(T^i,U^i_\text{init})| < 10^{-6}\alpha$ \textbf{and} \textbf{!}  \texttt{t\_stationary} \\
\hspace{40pt} \textbf{break} \hspace{10pt} // Safe to early exit \\
\hspace{30pt} \textbf{end if} \\

\hspace{20pt} \textbf{else}  \\
\hspace{30pt} \texttt{v\_converged} $\leftarrow $ \textbf{true} \\
\hspace{20pt} \textbf{end if} \\

\hspace{10pt} $\textbf{end while}$ \\

\hspace{10pt}  $(T^{k},U^{k}) \leftarrow (T^{i},U^{i})$ \\

\hspace{10pt} $k \leftarrow k + 1$ \\

\hspace{10pt} \texttt{converged} $\leftarrow$ \texttt{v\_converged} \textbf{and}   \texttt{t\_stationary}  \textbf{and} \texttt{d\_stationary} \\

 $\textbf{end while}$ \\
 
 $(T^{*},U^{*}) \leftarrow (T^{k-1},U^{k-1})$

\end{algorithm}

With the key components now in place, Algorithm 1 summarizes our full OptCuts algorithm in pseudocode, including details on convergence detection and termination. 
Here, in this section, we next discuss details of OptCuts convergence at termination, and 
then follow with technical details of our implementation of OptCuts. 
%First, we describe our choices for obtaining the initial embeddings. Second, we provide details on continuous search that we use during our smooth descent step. Finally, we provide some details on enforcing and maintaining bijectivity. 

\subsection{Termination and Convergence}

Our primal solution is \emph{converged} whenever it is stationary with respect to variations in both topology \emph{and} vertex position for a fixed $\lambda^k$ multiplier value. Numerically, primal convergence is declared for any $(T^i,U^i)$ pair when 1.) the topology descent is stationary---meaning there are no further available mesh operations at the current multiplier $\lambda^k$ value that will give decrease to the Lagrangian below $L(T^i,U^i,\lambda^k)$ at all; and 2.) the smooth distortion energy at topology $T^i$ is sufficiently locally minimized so that $\| \nabla_{\small{U}} E_{d}(T^i,U^i)\| \leq 10^{-6}$. When both our primal solve is converged \emph{and} our dual variable is likewise close to stationary so that $| \lambda^k -  \lambda^{k-1}| < 10^{-3}$, OptCuts terminates with a solution that is numerically \emph{converged} to a local minimizer of (\ref{eq:p1}) with respect to all available variations in topology provided by our merge and cut operations. 

Importantly, we note that our OptCuts algorithm and our implementation thereof do not apply a maximum iteration cap anywhere in any of our iteration loops. All presented results and corresponding timings are from solutions that have converged as defined above and in the pseudocode in Algorithm 1. There is, however, one additional, but subtle detail for a robust implementation that warrants further discussion in text rather than in pseudocode---we cover this immediately below.

First while we converge with respect to the mesh operations we make available, we of course do not cover all possible topological operations on a mesh. Our choice of propagated cutting and merging operations was selected to cover the basic topology changes that we find suitably expressive for our parameterization task. However, we expect many others to be useful; indeed, below in Section~\ref{sec:var} we also consider and compare with another interesting mesh operation subset and remark that there is interesting future work to find improved mesh operation subsets for OptCuts. In the meantime, for \emph{any} discrete subset of topological operations that do not fully cover all possible mesh changes, there can and occasionally will be, a number of neighboring topologies connected by valid mesh operations that are all numerically close to stationarity. In such cases, without additional handling and preparation for cycling behavior OptCuts would oscillate without stopping between a number of equally high-quality, close-to-optimal solutions. To handle this rare but important case, we employ a simple cycle detection strategy, where we save hashes of the last $T$\danny{Minchen: what is T?} solution triplets and the best visited solution from the previous iteration. When we detect that a duplicate solution is being revisited we terminate with the best visited solution from the last iteration. Of the 254 examples computed with OptCuts in Section~\ref{sec:results} this cycling behavior appears in 171 cases. We also note that as we tighten the distortion bound cycling behavior decreases as stationary points become denser near isometric maps.

\subsection{Initialization}
%\minchen{to $E_d$ stationary point}% huh?
To initialize our UV map, $(T^0,U^0)$, for an input surface, we map its initial seam to a circle preserving edge lengths and parameterize the remaining vertices with Tutte's embedding~\shortcite{tutte1963draw} using uniform weights to ensure bijectivity.
% Danny: we don't currently do higher genus yet - nothing stopping us but unless we get it in, in time the following needs to go and move to the future work section.
%We compute initial seams for surfaces according to topology and geometry. 
For disk-topology surfaces, we simply pick the longest boundary as an initial seam while for genus-0 closed surfaces, we randomly pick two connected edges as an initial seam. 
%For higher-genus surfaces, we follow Crane et al.~\shortcite{Crane:2013:DGP} to detect homology generators, and connect all of them as an initial seam.
%%
Recall that we then start OptCuts by initializing $\lambda^0 = 0$. This sets the first iteration to initially ignore distortion and to begin by exploring a shortening of seam-lengths first.
%From the initial UV map, we simply start the optimization by ignoring the distortion constraints with $\lambda$ set to $0$ and let our dual update to modify $\lambda$ according to the distortion of intermediate results.

%\danny{Minchen: are we likely to do this next experiment in time? I think it's low priority -- we may just want to get rid of this next section?}
%For closed surfaces, the initial seam choice is one of many possibilities. To demonstrate insensitivity of our final embedding to this choice, %show that we can always find a local optimum with respect to both the UV topology and coordinates regardless of initial embedding, 
%we run our method on a closed input surface with several randomly picked initial seams, as well as a heuristic initial seam that splits the shortest path between two farthest points on the surface. As demonstrated in \minchen{Figure~\ref{fig:any_init_ends_well}}, we produce high quality UV maps under the given distortion bound for all initializations.

\subsection{Minimizing Distortion}
\label{sec:descentStep}

Each smooth descent step takes as input a possibly updated UV map from the previous topology descent step and applies a single Newton-type iteration to reduce $E_d$ over changes in vertex positions $U$ while holding topology, $T$.
%
%\begin{algorithm}[h]
%\SetAlgoLined
%\KwData{$M$, $T^{k,i}$, $U_a^{k,i-1}$}
%\KwResult{$U^{k,i}$, $\delta^{k,i}$}
%$g^{k,i-1} \leftarrow \nabla E_{d}(T^{k,i}, U_a^{k,i-1})$\;
%\If{$||g^{k,i-1}||^2 < 10^{-12}$}{
%	converge\;
%}
%compute $E_{d}$ Hessian proxy $P^{k,i-1}$\;
%solve $P^{k,i-1} p^{k,i-1} = -g^{k,i-1}$ for search direction $p^{k,i-1}$\;
%compute initial step size $\alpha^{k,i-1}_0$\;
%back-tracking line search with Armijo rule to obtain $\alpha^{k,i-1}$\;
%$U^{k,i} \leftarrow U_a^{k,i-1} + \alpha^{k,i-1} p^{k,i-1}$\;
%$\delta^{k,i} \leftarrow E_{d}(T^{k,i}, U^{k,i}) - E_{d}(T^{k,i}, U_a^{k,i-1})$\;
%\If{$|\delta^{k,i}/E_{d}(T^{k,i}, U_a^{k,i-1})| < 10^{-6}\alpha^{k,i-1}$}{
%	stop\;
%}
%\caption{Smooth Descent Step $(k+1,i)$}
%\label{alg:descentStep}
%\end{algorithm}
As our distortion energies $E_{d}$ are generally nonconvex, we apply Teran et al.'s\ \shortcite{Teran2005Robust} projected-Newton (PN) method to gain a modified Hessian proxy that is guaranteed PSD. We parallelized PN's per-element Hessian construction,   projection and assembly into the PN Hessian proxy, $H$, with Intel TBB~\cite{Reinders2007Intel}.  We the apply PARDISO~\cite{pardiso-6.0a, pardiso-6.0b} to solve the resulting linear system for the next descent direction. For line search we first use Smith and Schaefer's~\shortcite{Smith2015Bijective} line-search filter to avoid element inversion followed by standard line search with Armijo conditions~\shortcite{Armijo1966Minimization} to ensure sufficient energy decrease. Finally, we employ one additional optimization that is specific to OptCuts: On smooth steps where we are \emph{not} yet stationary with respect topology operations, there is no need to expend extra iterations to gain tight convergence on distortion. In these cases we terminate iterations when we simply have the more relaxed condition of small change in energy. On the other hand, when a stationary topology is reached, we then always require and apply full convergence to small gradient norm of $E_d$; see Algorithm 1.
%$ H p = - \nabla E_d(U)$ to gain descent direction $p$.

%to project the Hessian of each energy element to its closest symmetric positive definite (SPD) matrix in parallel with Intel TBB~\cite{Reinders2007Intel} and assemble the local Hessians to form an SPD Hessian proxy $P$ for the full mesh. We use the PARDISO~\cite{pardiso-6.0a, pardiso-6.0b} symmetric indefinite solver to solve the linear system $P p = -g$ for search direction $p$. \minchen{[TODO] change to use SPD solver by fixing a direction to ensure definiteness} As $E_{d}$ is also a barrier-type energy, it is essential to ensure that the configuration always stays inside the feasible region. Thus, we follow Smith and Schaefer~\shortcite{Smith2015Bijective} to compute an initial step size $\alpha_0$ that avoids element inversion and then conduct back-tracking line search with Armijo rule~\cite{Armijo1966Minimization} to ensure sufficient energy decrease.
%
%Besides a relatively small tolerance on $g$ for convergence detection, we apply another relative energy decrease criteria to appropriately stop the process while necessary.
%This can stop our continuous search at the true local optimum infinitesimal better than setting a larger gradient tolerance since our energy is highly nonlinear. \justin{I didn't follow this paragraph.}

\subsection{Global Bijectivity}
\label{sec:bijectivity}

Following Jiang et al.\ \shortcite{Jiang2017Simplicial}, we apply global bijectivity constraints to our mapping by (re-)triangulating void regions each time we update our UV map. We use Triangle library~\cite{shewchuk1996triangle}. Void regions consist of all holes as well as a loose bounding box enclosing the UV map.
We then add to our distortion energy $E_d$ an additional term \emph{not included in the distortion bound constraint} to form a collapse-preventing energy for the added negative-space triangles during each primal optimization iteration.

Our continuous descent steps on vertices then remains otherwise unchanged.
However, for each topology step, we need to ensure that negative-space triangles are inserted correctly for each query of a candidate local topological operation.

\danny{Minchen: ping me to discuss these next 2 paragraphs - not sure it's consistent with what I thought you were doing.}
Instead of reusing a loose bounding box, we take the current negative-space triangles into consideration when building up the local stencil near the edited seam. Since the boundary of the local stencils are all fixed during the query, this naturally prevents potential global overlaps with geodesically faraway UV elements. Similarly, the collapse preventing energy on the negative-space triangles is not involved in the computation of first-order reduction.

In splitting operations only, we also need to carefully push the split vertices in the opposite direction of their curvature normals before the querying optimization. This ensures that the initial local stencil has a collapse-free void region so that it could be triangulated correctly.
%Following Jiang et al.\ \shortcite{Jiang2017Simplicial}, we realize the global bijectivity constraint on our mapping by first triangulating the void regions of each iterations updated UV map using Triangle library~\cite{shewchuk1996triangle}. The void regions consist of all holes and the surrounding space of the UV map, bounded by the parameterization's boundaries and a loose bounding box.
%We augment our distortion energy $E_d$ with an additional term \emph{not included in the distortion bound constraint} to form a collapse-preventing energy for the added negative-space triangles during each optimization iteration.
%
%With this augmentation, our continuous search stays the same, while for our topology search, we need to also ensure that the negative-space triangles are added correctly when we query for our local topological operations.
%Instead of reusing a loose bounding box, we take the current negative-space triangles into consideration when building up the local stencil near the edited seam. Since the boundary of the local stencils are all fixed during the query, this naturally prevents potential global overlaps with geodesically faraway UV elements. Similarly, the collapse preventing energy on the negative-space triangles is not involved in the computation of first-order reduction.
%In splitting operations only, we also need to carefully push the split vertices in the opposite direction of their curvature normals before the querying optimization. This ensures that the initial local stencil has a collapse-free void region so that it could be triangulated correctly.

%\paragraph{Potential Accelerations for Practical Use}
%Since our topological operations only change the mesh locally both on connectivity and coordinates, we could also update the Hessian or the decomposition locally to save time. Besides, it is also interesting to try other Hessian approximation methods like L-BFGS~\cite{Liu1989Limited} or composite majorization~\cite{Shtengel2017Geometric} to explore further acceleration by finding a balance between per-iteration computational cost and convergence rate.
%\justin{not sure previous paragraph is needed}


